<!DOCTYPE html>
<!--
  Standalone Story Tree player template
  Sections:
    • Error panel shown when JSON fails to load
    • Start screen with title and launch button
    • Player screen containing image frame, overlays, controls, and audio element
  CSS and JavaScript are kept inline so the file can be distributed without a build step.
-->
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Story Tree Player</title>
    <link rel="stylesheet" href="./player-theme.css" />
    <style>
      :root {
        color-scheme: light;
        --bg: var(--color-page);
        --panel: var(--color-surface);
        --accent: var(--color-highlight);
        --text: var(--color-text-primary);
        --muted: var(--color-text-muted);
        --danger: #ff6b6b;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: var(--font-sans-stack, "Inter", "Helvetica Neue", Arial, sans-serif);
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 24px;
      }

      #player-root {
        width: min(1344px, 100%);
        position: relative;
        background: var(--panel);
        border-radius: 24px;
        border: 1px solid var(--color-border);
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .hidden {
        display: none !important;
      }

      .message {
        padding: 32px;
        text-align: center;
        color: var(--danger);
        font-size: 18px;
      }

      #start-screen,
      #player-screen {
        display: flex;
        flex-direction: column;
        min-height: 480px;
        background: var(--panel);
      }

      .player-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 24px;
        padding: 22px 28px;
        border-bottom: 1px solid var(--color-border);
        background: var(--panel);
      }

      .player-header-copy {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .player-label {
        margin: 0;
        text-transform: uppercase;
        font-size: 11px;
        letter-spacing: 0.3em;
        color: var(--muted);
      }

      .player-title {
        margin: 0;
        font-size: 20px;
        font-weight: 600;
        color: var(--text);
      }

      .player-status {
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.2em;
        color: var(--muted);
      }

      .player-main {
        position: relative;
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--color-page);
        padding: 20px 28px;
      }

      .image-frame {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        width: min(100%, 960px);
        min-height: 360px;
        border-radius: 24px;
        border: 1px solid var(--color-border);
        background: var(--color-surface-muted);
        overflow: hidden;
      }

      #shot-image {
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        object-fit: contain;
      }

      #image-placeholder {
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 24px;
        text-align: center;
        font-size: 14px;
        color: var(--muted);
      }

      .start-main {
        padding: 0;
      }

      .start-visual {
        position: absolute;
        inset: 0;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--color-page);
      }

      .start-visual img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        filter: blur(32px);
        transform: scale(1.12);
        opacity: 0.8;
      }

      .start-visual::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.7));
      }

      .start-overlay {
        position: relative;
        z-index: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
        border-radius: 20px;
        background: var(--panel);
        backdrop-filter: blur(14px);
        padding: 28px 36px;
        max-width: 420px;
        width: 100%;
        text-align: center;
      }

      .player-footer {
        padding: 18px 28px;
        border-top: 1px solid var(--color-border);
        display: flex;
        justify-content: flex-end;
        gap: 12px;
        background: var(--panel);
      }

      .player-footer span {
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: var(--muted);
      }

      .overlay {
        position: absolute;
        inset: 0;
        background: rgba(255, 255, 255, 0.75);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 32px;
        backdrop-filter: blur(12px);
      }

      .choice-content {
        width: 100%;
        max-width: 720px;
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .choice-prompt-card {
        border-radius: 20px;
        border: 1px solid var(--color-border);
        background: var(--panel);
        padding: 18px 26px;
        text-align: left;
      }

      #choice-prompt {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
        color: var(--text);
      }

      .choice-options {
        display: grid;
        gap: 16px;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }

      .choice-button {
        border-radius: 18px;
        overflow: hidden;
        background: var(--panel);
        border: 1px solid var(--color-border);
        padding: 0;
        display: flex;
        flex-direction: column;
        cursor: pointer;
        transition: transform 120ms ease, border-color 120ms ease;
      }

      .choice-button:hover {
        transform: translateY(-2px);
        border-color: var(--accent);
      }

      .choice-button img {
        display: block;
        width: 100%;
        height: auto;
        background: var(--color-surface-muted);
      }

      .choice-button .thumbnail-placeholder {
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--muted);
        font-size: 13px;
        padding: 20px;
        background: var(--color-surface-muted);
      }

      .choice-button span {
        padding: 16px;
        font-size: 15px;
        font-weight: 600;
        color: var(--text);
      }

      .overlay-content {
        background: var(--panel);
        border: 1px solid var(--color-border);
        border-radius: 20px;
        padding: 28px;
        text-align: center;
        display: flex;
        flex-direction: column;
        gap: 18px;
        width: min(360px, 100%);
      }

      .overlay-content p {
        margin: 0;
        color: var(--text);
        font-size: 14px;
        line-height: 1.6;
      }

      button {
        appearance: none;
        border-radius: 999px;
        border: 1px solid var(--accent);
        background: var(--accent);
        color: #fff;
        font-size: 14px;
        font-weight: 600;
        padding: 12px 24px;
        cursor: pointer;
        transition: opacity 150ms ease;
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      button:not(:disabled):hover {
        opacity: 0.92;
      }

      #play-pause-button {
        border: 1px solid var(--color-border);
        border-radius: 999px;
        padding: 10px 22px;
        font-size: 11px;
        font-weight: 600;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        background: transparent;
        color: var(--text);
        transition: background 150ms ease, color 150ms ease, opacity 150ms ease;
      }

      #play-pause-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      #play-pause-button:not(:disabled):hover {
        background: rgba(0, 0, 0, 0.04);
        opacity: 1;
      }

      #play-pause-button:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 4px;
      }

      .player-footer button {
        background: none;
        border: none;
        padding: 0;
        font-size: 11px;
        font-weight: 600;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: var(--muted);
        cursor: pointer;
        transition: color 150ms ease;
      }

      .player-footer button:hover {
        color: var(--text);
      }

      .player-footer button:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 4px;
      }

      @media (max-width: 768px) {
        body {
          padding: 12px;
        }

        #player-root {
          border-radius: 18px;
        }

        .player-header,
        .player-main,
        .player-footer {
          padding-left: 18px;
          padding-right: 18px;
        }

        .choice-options {
          grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }

        .start-overlay {
          padding: 24px;
        }
      }
    </style>
  </head>
  <body>
    <script id="story-data" type="application/json">__STORY_JSON_PLACEHOLDER__</script>
    <div id="player-root">
      <div id="error-panel" class="message hidden"></div>
      <div id="start-screen" class="hidden">
        <header class="player-header">
          <div class="player-header-copy">
            <p class="player-label">Interactive Story</p>
            <h2 id="start-title" class="player-title"></h2>
          </div>
          <span class="player-status">Ready to begin</span>
        </header>
        <main class="player-main start-main">
          <div id="start-visual" class="start-visual hidden">
            <img id="start-image" class="hidden" alt="" />
          </div>
          <div class="start-overlay">
            <button id="start-button" type="button">Start Story</button>
          </div>
        </main>
        <footer class="player-footer">
          <span class="player-status">Awaiting playback</span>
        </footer>
      </div>
      <div id="player-screen" class="hidden">
        <header class="player-header">
          <div class="player-header-copy">
            <p class="player-label">Interactive Story</p>
            <h2 id="story-title" class="player-title"></h2>
          </div>
          <button id="play-pause-button" type="button" disabled>Pause</button>
        </header>
        <main class="player-main">
          <div class="image-frame">
            <img id="shot-image" alt="Current story shot" class="hidden" />
            <div id="image-placeholder" class="hidden">Visual not available for this moment.</div>
            <div id="choice-overlay" class="overlay hidden">
              <div class="choice-content">
                <div class="choice-prompt-card">
                  <h2 id="choice-prompt"></h2>
                </div>
                <div id="choice-options" class="choice-options"></div>
              </div>
            </div>
            <div id="terminal-overlay" class="overlay hidden">
              <div class="overlay-content">
                <p>You reached a story ending. Feel free to experience it again.</p>
                <button id="restart-button" type="button">Start Over</button>
              </div>
            </div>
            <div id="incomplete-overlay" class="overlay hidden">
              <div class="overlay-content">
                <p>
                  This path is still being authored. The story will resume once more content is
                  available.
                </p>
              </div>
            </div>
          </div>
        </main>
        <footer class="player-footer">
          <button id="restart-footer-button" type="button">Restart Story</button>
        </footer>
        <audio id="shot-audio" preload="auto"></audio>
        <audio id="music-primary" preload="auto" loop></audio>
        <audio id="music-secondary" preload="auto" loop></audio>
      </div>
    </div>
    <script type="module">
      const { createPlayerController } = (() => {
__PLAYER_RUNTIME_PLACEHOLDER__
        return { createPlayerController };
      })();

      const MUSIC_VOLUME = 0.25;
      const MUSIC_CROSSFADE_MS = 500;
      const MUSIC_FADE_INTERVAL_MS = 50;

      const elements = {
        root: document.getElementById("player-root"),
        error: document.getElementById("error-panel"),
        startScreen: document.getElementById("start-screen"),
        startVisual: document.getElementById("start-visual"),
        startImage: document.getElementById("start-image"),
        startTitle: document.getElementById("start-title"),
        startButton: document.getElementById("start-button"),
        playerScreen: document.getElementById("player-screen"),
        storyTitle: document.getElementById("story-title"),
        shotImage: document.getElementById("shot-image"),
        imagePlaceholder: document.getElementById("image-placeholder"),
        playPauseButton: document.getElementById("play-pause-button"),
        choiceOverlay: document.getElementById("choice-overlay"),
        choicePrompt: document.getElementById("choice-prompt"),
        choiceOptions: document.getElementById("choice-options"),
        terminalOverlay: document.getElementById("terminal-overlay"),
        restartButton: document.getElementById("restart-button"),
        restartFooterButton: document.getElementById("restart-footer-button"),
        incompleteOverlay: document.getElementById("incomplete-overlay"),
        audio: document.getElementById("shot-audio"),
        musicPrimary: document.getElementById("music-primary"),
        musicSecondary: document.getElementById("music-secondary"),
      };

      const state = {
        controller: null,
        audioShouldResume: false,
        currentStage: "idle",
      };

      let sceneletLookup = new Map();
      const failedCues = new Set();

      const musicState = {
        activeElement: null,
        pendingElement: null,
        fadeTimer: null,
        pendingCue: null,
        pausedElements: [],
        currentCue: null,
      };

      initialize();

      function initialize() {
        const storyDataElement = document.getElementById("story-data");
        const rawStoryData = storyDataElement?.textContent ?? "";
        if (!rawStoryData.trim()) {
          showError("Embedded story data is missing. Rebuild the bundle and try again.");
          return;
        }

        let story;
        try {
          story = JSON.parse(rawStoryData);
        } catch {
          showError("Story JSON is not valid.");
          return;
        }

        storyDataElement?.remove();
        sceneletLookup = buildSceneletLookup(story);

        let controller;
        try {
          controller = createPlayerController(story);
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          showError(`Failed to load embedded story data.\n${message}`);
          return;
        }

        state.controller = controller;
        wireControllerEvents(controller);
        setupStaticUi(story);
        showStartScreen();

        elements.startButton.addEventListener("click", () => {
          if (!state.controller) {
            return;
          }
          clearError();
          hideAllOverlays();
          showPlayerScreen();
          state.controller.start();
        });

        elements.playPauseButton.addEventListener("click", () => {
          if (!state.controller) {
            return;
          }
          if (
            state.currentStage === "idle" ||
            state.currentStage === "choice" ||
            state.currentStage === "terminal" ||
            state.currentStage === "incomplete"
          ) {
            return;
          }
          const { isPaused } = state.controller.getState();
          if (isPaused) {
            state.controller.resume();
          } else {
            state.controller.pause();
          }
        });

        elements.restartButton.addEventListener("click", () => {
          if (!state.controller) {
            return;
          }
          hideAllOverlays();
          showPlayerScreen();
          state.controller.restart();
        });

        elements.restartFooterButton?.addEventListener("click", () => {
          if (!state.controller) {
            return;
          }
          hideAllOverlays();
          showPlayerScreen();
          state.controller.restart();
        });

        elements.audio.addEventListener("ended", () => {
          state.controller?.notifyShotAudioComplete();
        });

        elements.audio.addEventListener("error", () => {
          state.controller?.notifyShotAudioError();
        });

        [elements.musicPrimary, elements.musicSecondary].forEach((element) => {
          if (!element) {
            return;
          }
          element.volume = 0;
          element.loop = true;
          element.addEventListener("error", () => {
            const cueName = element.dataset?.cueName ?? "";
            if (cueName) {
              failedCues.add(cueName);
            }
            fadeOutMusic(true);
          });
        });
      }

      function wireControllerEvents(controller) {
        controller.subscribe("story-ready", (event) => {
          const title = event.metadata?.title?.trim?.() || "Untitled Story";
          elements.startTitle.textContent = title;
          elements.storyTitle.textContent = title;
        });

        controller.subscribe("stage-change", ({ stage }) => {
          state.currentStage = stage;
          if (stage !== "choice") {
            elements.choiceOverlay.classList.add("hidden");
          }
          if (stage !== "terminal") {
            elements.terminalOverlay.classList.add("hidden");
          }
          if (stage !== "incomplete") {
            elements.incompleteOverlay.classList.add("hidden");
          }
          updatePlayPauseButton();
        });

        controller.subscribe("scenelet-enter", () => {
          hideAllOverlays();
        });

        controller.subscribe("shot-enter", ({ shot }) => {
          hideAllOverlays();
          updateShotImage(shot);
        });

        controller.subscribe("audio-start", ({ audioPath, requiresUserInteraction }) => {
          playShotAudio(audioPath, requiresUserInteraction);
        });

        controller.subscribe("audio-missing", stopShotAudio);

        controller.subscribe("branch", (event) => {
          renderBranchChoices(event);
        });

        controller.subscribe("terminal", () => {
          elements.terminalOverlay.classList.remove("hidden");
          stopShotAudio();
          fadeOutMusic();
          updatePlayPauseButton();
        });

        controller.subscribe("incomplete", () => {
          elements.incompleteOverlay.classList.remove("hidden");
          stopShotAudio();
          fadeOutMusic();
          updatePlayPauseButton();
        });

        controller.subscribe("pause-change", ({ isPaused }) => {
          if (isPaused) {
            if (!elements.audio.paused && !elements.audio.ended && elements.audio.currentTime > 0) {
              state.audioShouldResume = true;
              elements.audio.pause();
            } else {
              state.audioShouldResume = false;
            }
            pauseBackgroundMusic();
          } else {
            if (state.audioShouldResume) {
              state.audioShouldResume = false;
              elements.audio.play().catch(() => controller.notifyShotAudioError());
            }
            resumeBackgroundMusic();
          }
          updatePlayPauseButton();
        });

        controller.subscribe("music-change", ({ cueName, audioPath }) => {
          if (!audioPath || !cueName) {
            fadeOutMusic();
            return;
          }
          if (failedCues.has(cueName)) {
            return;
          }
          crossfadeToCue(cueName, audioPath);
        });
      }

      function setupStaticUi(story) {
        const title = story?.metadata?.title?.trim?.() || "Untitled Story";
        elements.startTitle.textContent = title;
        elements.storyTitle.textContent = title;
        updateStartVisual(story);
      }

      function buildSceneletLookup(story) {
        const map = new Map();
        if (!story || !Array.isArray(story.scenelets)) {
          return map;
        }
        for (const scenelet of story.scenelets) {
          if (scenelet && typeof scenelet.id === "string") {
            map.set(scenelet.id, scenelet);
          }
        }
        return map;
      }

      function showStartScreen() {
        stopShotAudio();
        fadeOutMusic(true);
        hideAllOverlays();
        elements.playerScreen.classList.add("hidden");
        elements.startScreen.classList.remove("hidden");
        state.currentStage = "idle";
        updatePlayPauseButton();
      }

      function showPlayerScreen() {
        elements.startScreen.classList.add("hidden");
        elements.playerScreen.classList.remove("hidden");
      }

      function clearError() {
        elements.error.textContent = "";
        elements.error.classList.add("hidden");
      }

      function showError(message) {
        stopShotAudio();
        fadeOutMusic(true);
        elements.playerScreen.classList.add("hidden");
        elements.startScreen.classList.add("hidden");
        elements.error.textContent = message;
        elements.error.classList.remove("hidden");
      }

      function hideAllOverlays() {
        elements.choiceOverlay.classList.add("hidden");
        elements.terminalOverlay.classList.add("hidden");
        elements.incompleteOverlay.classList.add("hidden");
      }

      function updateShotImage(shot) {
        if (shot?.imagePath) {
          elements.shotImage.src = shot.imagePath;
          elements.shotImage.classList.remove("hidden");
          elements.imagePlaceholder.classList.add("hidden");
        } else {
          elements.shotImage.src = "";
          elements.shotImage.classList.add("hidden");
          elements.imagePlaceholder.classList.remove("hidden");
        }
      }

      function playShotAudio(audioPath, requiresUserInteraction) {
        elements.audio.pause();
        elements.audio.src = audioPath;
        elements.audio.currentTime = 0;
        state.audioShouldResume = false;
        const playPromise = elements.audio.play();
        if (playPromise && typeof playPromise.catch === "function") {
          playPromise.catch((error) => {
            console.warn("Shot audio failed to play.", { error });
            if (requiresUserInteraction) {
              state.controller?.notifyShotAudioError();
            }
          });
        }
      }

      function stopShotAudio() {
        elements.audio.pause();
        if (elements.audio.hasAttribute("src")) {
          elements.audio.removeAttribute("src");
          elements.audio.load();
        }
        state.audioShouldResume = false;
      }

      function renderBranchChoices(event) {
        elements.choicePrompt.textContent = event.prompt;
        elements.choiceOptions.innerHTML = "";

        for (const choice of event.choices) {
          const button = document.createElement("button");
          button.type = "button";

          const preview = findPreviewImage(choice.sceneletId);
          if (preview) {
            const img = document.createElement("img");
            img.src = preview;
            img.alt = choice.label;
            button.appendChild(img);
          } else {
            const placeholder = document.createElement("div");
            placeholder.className = "thumbnail-placeholder";
            placeholder.textContent = "Preview unavailable";
            button.appendChild(placeholder);
          }

          const label = document.createElement("span");
          label.textContent = choice.label;
          button.appendChild(label);

          button.addEventListener("click", () => {
            if (!state.controller) {
              return;
            }
            elements.choiceOverlay.classList.add("hidden");
            state.controller.chooseBranch(choice.sceneletId);
          });

          elements.choiceOptions.appendChild(button);
        }

        elements.choiceOverlay.classList.remove("hidden");
      }

      function updatePlayPauseButton() {
        if (!state.controller) {
          elements.playPauseButton.disabled = true;
          elements.playPauseButton.textContent = "Pause";
          return;
        }
        const { isPaused } = state.controller.getState();
        const shouldDisable =
          state.currentStage === "idle" ||
          state.currentStage === "choice" ||
          state.currentStage === "terminal" ||
          state.currentStage === "incomplete";
        elements.playPauseButton.disabled = shouldDisable;
        elements.playPauseButton.textContent = isPaused ? "Play" : "Pause";
      }

      function updateStartVisual(story) {
        const imagePath = findOpeningShotImage(story);
        const startVisual = elements.startVisual;
        const startImage = elements.startImage;
        if (!startVisual || !startImage) {
          return;
        }
        if (imagePath) {
          startImage.src = imagePath;
          startImage.classList.remove("hidden");
          startVisual.classList.remove("hidden");
        } else {
          startImage.removeAttribute("src");
          startImage.classList.add("hidden");
          startVisual.classList.add("hidden");
        }
      }

      function findOpeningShotImage(story) {
        if (!story || !Array.isArray(story.scenelets)) {
          return null;
        }
        const root =
          story.scenelets.find((scenelet) => scenelet?.id === story.rootSceneletId) ??
          story.scenelets[0];
        if (!root || !Array.isArray(root.shots)) {
          return null;
        }
        for (const shot of root.shots) {
          if (shot && typeof shot.imagePath === "string" && shot.imagePath.trim()) {
            return shot.imagePath;
          }
        }
        return null;
      }

      function findPreviewImage(sceneletId) {
        const scenelet = sceneletLookup.get(sceneletId);
        if (!scenelet || !Array.isArray(scenelet.shots)) {
          return null;
        }
        for (const shot of scenelet.shots) {
          if (shot && typeof shot.imagePath === "string" && shot.imagePath.trim()) {
            return shot.imagePath;
          }
        }
        return null;
      }

      function pauseBackgroundMusic() {
        musicState.pausedElements = [];
        [elements.musicPrimary, elements.musicSecondary].forEach((element) => {
          if (element && !element.paused && element.currentTime > 0) {
            element.pause();
            musicState.pausedElements.push(element);
          }
        });
      }

      function resumeBackgroundMusic() {
        const toResume = Array.isArray(musicState.pausedElements)
          ? musicState.pausedElements
          : [];
        musicState.pausedElements = [];
        toResume.forEach((element) => {
          element.play().catch((error) => {
            const cueName = element.dataset?.cueName ?? musicState.currentCue ?? "";
            if (cueName) {
              failedCues.add(cueName);
            }
            console.warn("Background music failed to resume after pause.", { cueName, error });
            fadeOutMusic(true);
          });
        });
      }

      function crossfadeToCue(cueName, audioPath) {
        const incoming = getInactiveMusicElement();
        if (!incoming) {
          console.warn("No audio element available for background music playback.");
          return;
        }

        clearMusicFadeTimer();
        musicState.pendingCue = cueName;
        musicState.pendingElement = incoming;

        resetMusicElement(incoming);
        incoming.dataset.cueName = cueName;
        incoming.src = audioPath;
        incoming.currentTime = 0;
        incoming.volume = 0;

        const playPromise = incoming.play();
        if (playPromise && typeof playPromise.catch === "function") {
          playPromise.catch((error) => {
            console.warn("Unable to start background music cue.", { cueName, error });
            failedCues.add(cueName);
            if (musicState.pendingCue === cueName) {
              musicState.pendingCue = null;
              musicState.pendingElement = null;
            }
            fadeOutMusic(true);
          });
        }

        const outgoing =
          musicState.activeElement && musicState.activeElement !== incoming
            ? musicState.activeElement
            : null;

        if (!outgoing || MUSIC_CROSSFADE_MS === 0) {
          if (outgoing) {
            resetMusicElement(outgoing);
          }
          incoming.volume = MUSIC_VOLUME;
          musicState.activeElement = incoming;
          musicState.currentCue = cueName;
          musicState.pendingCue = null;
          musicState.pendingElement = null;
          return;
        }

        const startTime = performance.now();
        musicState.fadeTimer = window.setInterval(() => {
          const elapsed = performance.now() - startTime;
          const progress = Math.min(elapsed / MUSIC_CROSSFADE_MS, 1);
          incoming.volume = MUSIC_VOLUME * progress;
          outgoing.volume = MUSIC_VOLUME * (1 - progress);

          if (progress >= 1) {
            clearMusicFadeTimer();
            resetMusicElement(outgoing);
            incoming.volume = MUSIC_VOLUME;
            musicState.activeElement = incoming;
            musicState.currentCue = cueName;
            musicState.pendingCue = null;
            musicState.pendingElement = null;
          }
        }, Math.max(MUSIC_FADE_INTERVAL_MS, 16));
      }

      function fadeOutMusic(stopImmediately = false) {
        const active = musicState.activeElement;
        if (!active) {
          clearPendingCue();
          musicState.currentCue = null;
          return;
        }

        if (stopImmediately || MUSIC_CROSSFADE_MS === 0) {
          clearMusicFadeTimer();
          resetMusicElement(active);
          musicState.activeElement = null;
          musicState.currentCue = null;
          clearPendingCue();
          return;
        }

        clearMusicFadeTimer();
        const startTime = performance.now();
        musicState.fadeTimer = window.setInterval(() => {
          const elapsed = performance.now() - startTime;
          const progress = Math.min(elapsed / MUSIC_CROSSFADE_MS, 1);
          active.volume = MUSIC_VOLUME * (1 - progress);

          if (progress >= 1) {
            clearMusicFadeTimer();
            resetMusicElement(active);
            musicState.activeElement = null;
            musicState.currentCue = null;
            clearPendingCue();
          }
        }, Math.max(MUSIC_FADE_INTERVAL_MS, 16));
      }

      function clearMusicFadeTimer() {
        if (musicState.fadeTimer !== null) {
          clearInterval(musicState.fadeTimer);
          musicState.fadeTimer = null;
        }
      }

      function getInactiveMusicElement() {
        const primary = elements.musicPrimary;
        const secondary = elements.musicSecondary;
        if (!primary && !secondary) {
          return null;
        }
        const active = musicState.activeElement;
        if (!active) {
          return primary ?? secondary;
        }
        if (active === primary) {
          return secondary ?? primary;
        }
        return primary ?? secondary;
      }

      function resetMusicElement(element) {
        if (!element) {
          return;
        }
        element.pause();
        if (element.hasAttribute("src")) {
          element.removeAttribute("src");
          element.load();
        }
        element.volume = 0;
        if (element.dataset) {
          element.dataset.cueName = "";
        }
      }

      function clearPendingCue() {
        if (musicState.pendingElement) {
          resetMusicElement(musicState.pendingElement);
        }
        musicState.pendingElement = null;
        musicState.pendingCue = null;
      }
    </script>

  </body>
</html>
